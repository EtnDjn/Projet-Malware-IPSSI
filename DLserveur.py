import socket
import os

# Fonction pour réceptionner les données d'un client
def recv_data(conn):
    data_size = ""
    data_tag = ""
    data_content = b""  # Pour les données binaires

    # Lecture de la taille
    ch = conn.recv(1).decode()
    while ch != "#":
        data_size += ch
        ch = conn.recv(1).decode()
    
    # Lecture du tag
    ch = conn.recv(1).decode()
    while ch != "#":
        data_tag += ch
        ch = conn.recv(1).decode()

    # Lecture du contenu
    for i in range(int(data_size)):
        data_content += conn.recv(1)

    if data_tag == "MSG":
        print(data_content.decode())
    elif data_tag == "FILE" :
        filename, file_content = data_content.split(b'#', 1)
        filename = filename.decode() + "_copy"
        with open(os.path.basename(filename), 'wb') as file:  # Écrire le contenu dans un fichier
            file.write(data_content)
        print(f"Fichier '{filename}' reçu et sauvegardé.")
    else:
        print("Tag inconnu:", data_tag)

    return data_content

def send_data(conn, data):
    conn.sendall(data.encode())

# Socket serveur d'écoute
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind(("127.0.0.1", 12347))
    s.listen()
    print("Waiting for client...")
    conn, addr = s.accept() 
    #Logique principale après connexion à un client
    with conn:
        print("Connection received from:", addr)
        #Reception du menu
        menu = recv_data(conn)
        
        #Boucle infinie pour que la communication ne s'arrête que si elle reçoit QUIT
        while True:
            #Logique pour envoyer une commande
            command = input("Command ? :")
            if command.upper() == "QUIT" :
                send_data(conn, command)
                print("End of connection")
                break
            else :
                send_data(conn, command)

            #Logique selon la réponse du client
            data_content = recv_data(conn)
