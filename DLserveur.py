import socket
import os
import _thread
import threading

# Structure pour stocker les informations sur les clients
clients = {}
lock = threading.Lock()

def handle_client(client_id):
    conn = clients[client_id]
    print(f"Handling client: {client_id}")
    menu = recv_data(conn)
    try:
        while True:
            command = input("Command : ")
            if command.upper() == "QUIT" :
                send_data(conn, command)
                print("End of connection")
                break
            else :
                send_data(conn, command)
                try:
                    response = recv_data(conn)
                except Exception as e:
                    print(f"Error receiving response from {client_id}: {e}")
                    break
    except Exception as e:
        print(f"Error with {client_id}: {e}")
    finally:
        with lock:
            if client_id in clients:
                conn.close()
                del clients[client_id]
                print(f"Connection closed for {client_id}")

def interact_with_client():
    while True:
        with lock:
            if not clients:
                print("No clients connected.")
            for client_id in clients:
                print(client_id)
                
        selected_id = input("Enter the client ID to interact with (or 'exit' to quit): ")
        if selected_id.lower() == 'exit':
            break
            
        if selected_id in clients:
            conn = clients[selected_id]
            send_data(conn, "MENU")
            handle_client(selected_id)
        else:
            print("Client not found.")

# Fonction pour réceptionner les données d'un client
def recv_data(conn):
    data_size = ""
    data_tag = ""
    data_content = b""  # Pour les données binaires

    # Lecture de la taille
    ch = conn.recv(1).decode()
    while ch != "#":
        data_size += ch
        ch = conn.recv(1).decode()
    
    # Lecture du tag
    ch = conn.recv(1).decode()
    while ch != "#":
        data_tag += ch
        ch = conn.recv(1).decode()

    # Lecture du contenu
    for i in range(int(data_size)):
        data_content += conn.recv(1)

    if data_tag == "MSG":
        print(data_content.decode())
    elif data_tag == "FILE" :
        filename, file_content = data_content.split(b'#', 1)
        filename = filename.decode() + "_copy"
        with open(os.path.basename(filename), 'wb') as file:  # Écrire le contenu dans un fichier
            file.write(data_content)
        print(f"Fichier '{filename}' reçu et sauvegardé.")
    else:
        print("Tag inconnu:", data_tag)

    return data_content

def send_data(conn, data):
    conn.sendall(data.encode())

# Fonction pour démarrer le serveur et écouter les connexions entrantes
def start_server(host, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((host, port))
        s.listen()
        print(f"Server listening on {host}:{port}...")
        while True:
            conn, addr = s.accept()
            client_id = f"{addr[0]}:{addr[1]}"
            print(f"Client connected: {client_id}")
            with lock:
                clients[client_id] = conn


host = '127.0.0.1'
port = 12347 

server_thread = threading.Thread(target=start_server, args=(host, port))
server_thread.start()
    
interact_with_client()
server_thread.join()